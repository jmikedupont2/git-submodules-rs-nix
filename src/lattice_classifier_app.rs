//! This program demonstrates the conceptual use of generated lattice structures
//! to perform a simple "search by example" or "classification" task.
//! It classifies sample text snippets based on the presence of predefined predicates.

// In a real application, these would be imported from the generated code.
// For this conceptual example, we'll re-define simplified versions or assume their presence.

// --- Simplified Generated Types (Conceptual) ---
// These mirror the types that would be generated by `lattice_code_generator`

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum ValueType {
    Bit,
    PrimeValue(u8),
}

impl ValueType {
    pub fn count(&self) -> u8 {
        match self {
            ValueType::Bit => 2,
            ValueType::PrimeValue(p) => *p,
        }
    }
}

pub trait HasValueCount {
    fn value_count() -> u8;
}

impl HasValueCount for bool {
    fn value_count() -> u8 {
        2
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]
pub struct WordPredicate(bool);

impl HasValueCount for WordPredicate {
    fn value_count() -> u8 {
        2
    }
}

#[derive(Debug, Clone)]
pub struct Instance<T: HasValueCount + std::fmt::Debug> {
    pub id: String,
    pub n_gram_size: u8,
    pub units: Vec<T>,
}

impl<T: HasValueCount + std::fmt::Debug> Instance<T> {
    pub fn new(id: &str, n_gram_size: u8, units: Vec<T>) -> Self {
        Self { id: id.to_string(), n_gram_size, units }
    }

    pub fn describe(&self) {
        println!("  Instance ID: {}", self.id);
        println!("    N-gram Size: {}", self.n_gram_size);
        println!("    Underlying Value Type Count: {}", T::value_count());
        println!("    Units: {:?}", self.units);
    }
}

#[derive(Debug, Clone)]
pub struct LatticeLayer<T: HasValueCount + std::fmt::Debug> {
    pub value_type: ValueType,
    pub instances: Vec<Instance<T>>,
}

impl<T: HasValueCount + std::fmt::Debug> LatticeLayer<T> {
    pub fn new(value_type: ValueType) -> Self {
        Self { value_type, instances: Vec::new() }
    }

    pub fn add_instance(&mut self, instance: Instance<T>) {
        self.instances.push(instance);
    }

    pub fn describe(&self) {
        println!("\n--- Lattice Layer: {:?} (k={}) ---", self.value_type, self.value_type.count());
        for instance in &self.instances {
            instance.describe();
        }
    }
}

pub trait LatticeLayerTrait: std::fmt::Debug {
    fn describe_layer(&self);
}

impl<T: HasValueCount + std::fmt::Debug + 'static> LatticeLayerTrait for LatticeLayer<T> {
    fn describe_layer(&self) {
        self.describe();
    }
}

#[derive(Debug, Clone)]
pub struct Lattice {
    pub name: String,
    pub layers: Vec<Box<dyn LatticeLayerTrait>>,
}

impl Lattice {
    pub fn new(name: &str) -> Self {
        Self { name: name.to_string(), layers: Vec::new() }
    }

    pub fn add_layer<T: HasValueCount + std::fmt::Debug + 'static>(&mut self, layer: LatticeLayer<T>) {
        self.layers.push(Box::new(layer));
    }

    pub fn describe(&self) {
        println!("\n### Lattice Model: {} ###", self.name);
        for layer in &self.layers {
            layer.describe_layer();
        }
    }
}

// --- Classification Logic ---

/// Represents a simple classifier based on predicate presence.
struct PredicateClassifier {
    target_predicates: Vec<String>,
}

impl PredicateClassifier {
    fn new(predicates: Vec<&str>) -> Self {
        Self { target_predicates: predicates.into_iter().map(|s| s.to_lowercase()).collect() }
    }

    /// Classifies a text snippet based on whether it contains any of the target predicates.
    fn classify(&self, text: &str) -> bool {
        let lower_text = text.to_lowercase();
        self.target_predicates.iter().any(|p| lower_text.contains(p))
    }

    /// Extracts WordPredicates from text based on the classifier's target predicates.
    fn extract_word_predicates(&self, text: &str) -> Vec<WordPredicate> {
        let lower_text = text.to_lowercase();
        self.target_predicates.iter()
            .map(|p| WordPredicate(lower_text.contains(p)))
            .collect()
    }
}

fn main() {
    println!("\n--- Lattice Classifier Application ---");

    // 1. Define a classifier based on key predicates (concept words)
    let classifier = PredicateClassifier::new(vec!["lattice", "meme", "vibe", "math", "rust", "llm", "code"]);
    println!("Classifier initialized with predicates: {:?}", classifier.target_predicates);

    // 2. Sample items (e.g., code snippets, LLM responses, document excerpts)
    let items_to_classify = vec![
        ("Item A: This Rust program uses a lattice structure.", "A"),
        ("Item B: The memeification of ideas creates a vibe.", "B"),
        ("Item C: Deep learning models are complex.", "C"),
        ("Item D: Mathematical proofs are fundamental.", "D"),
        ("Item E: LLM knowledge extraction is key.", "E"),
    ];

    // 3. Classify and represent items as instances in the lattice
    let mut bit_layer = LatticeLayer::<WordPredicate>::new(ValueType::Bit);

    println!("\n--- Classification Results ---");
    for (text, id_suffix) in items_to_classify {
        let is_classified = classifier.classify(text);
        let word_predicates = classifier.extract_word_predicates(text);
        let instance_id = format!("Item_{}", id_suffix);

        let instance = Instance::new(&instance_id, word_predicates.len() as u8, word_predicates);
        bit_layer.add_instance(instance);

        println!("\n  Item: \"{}\"", text);
        println!("    Classified: {}", if is_classified { "YES" } else { "NO" });
        println!("    Predicates: {:?}", bit_layer.instances.last().unwrap().units);
    }

    // 4. Describe the conceptual lattice with classified instances
    let mut conceptual_lattice = Lattice::new("Classification Lattice");
    conceptual_lattice.add_layer(bit_layer);
    conceptual_lattice.describe();

    println!("\nThis program conceptually demonstrates how the generated lattice types can be used");
    println!("to classify and represent complex items based on predicate presence, forming a searchable lattice.");
}
